class Solution {
  public:
    // DFS helper
    bool dfs(int node, stack<int>& s, map<int, list<int>>& adj, 
             map<int, int>& visited) {
        visited[node] = 1; // mark as "in recursion stack"

        for (auto neighbour : adj[node]) {
            if (visited[neighbour] == 0) {
                if (!dfs(neighbour, s, adj, visited)) return false;
            } 
            else if (visited[neighbour] == 1) {
                // found a back edge → cycle
                return false;
            }
        }

        visited[node] = 2; // mark as "fully processed"
        s.push(node);
        return true;
    }

    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        // Build adjacency list
        map<int, list<int>> adj;
        for (auto& edge : prerequisites) {
            int u = edge[1]; // prerequisite → course
            int v = edge[0];
            adj[u].push_back(v);
        }

        map<int, int> visited; // 0 = not visited, 1 = visiting, 2 = done
        stack<int> s;

        // Run DFS on all courses
        for (int i = 0; i < numCourses; i++) {
            if (visited[i] == 0) {
                if (!dfs(i, s, adj, visited)) {
                    return {}; // cycle detected → no valid ordering
                }
            }
        }

        // Collect result
        vector<int> ans;
        while (!s.empty()) {
            ans.push_back(s.top());
            s.pop();
        }
        return ans;
    }
};
