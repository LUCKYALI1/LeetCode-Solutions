# Intuition
The problem describes a **circular array transformation** where each element in the array independently decides how far (and in which direction) we move from its index to pick a value for the result array.

Key observations:
- The array is **circular**, meaning indices can wrap around from the end to the start and vice versa.
- Each element `nums[i]` tells us:
  - Move **right** if it is positive
  - Move **left** if it is negative
  - Do nothing if it is zero
- The value placed in `result[i]` is **not the index**, but the **value at the index where we land**.

This naturally points to using **modulo arithmetic** to safely wrap indices inside array bounds.

---

# Approach
We iterate through the array once and compute the destination index for every position `i`.

### Step-by-step strategy:
1. Let `n` be the length of the array.
2. Create a `result` array of size `n`.
3. For each index `i`:
   - **If `nums[i] > 0`**
     - Move right by `nums[i]` steps.
     - Destination index:
       ```
       (i + nums[i]) % n
       ```
   - **If `nums[i] < 0`**
     - Move left by `abs(nums[i])` steps.
     - Since modulo with negatives can cause issues in C++, normalize it:
       ```
       (i + nums[i] % n + n) % n
       ```
   - **If `nums[i] == 0`**
     - Directly assign `0` to `result[i]`.

This ensures:
- No index goes out of bounds.
- Circular movement works correctly in both directions.

---

## Dry Run Example

### Input
nums = [2, -1, 0, 1]
n = 4


### Iteration Details

| i | nums[i] | Movement | New Index Calculation | New Index | result[i] |
|---|--------|----------|----------------------|-----------|-----------|
| 0 | 2 | Right 2 | (0 + 2) % 4 | 2 | nums[2] = 0 |
| 1 | -1 | Left 1 | (1 + (-1 % 4) + 4) % 4 | 0 | nums[0] = 2 |
| 2 | 0 | None | — | — | 0 |
| 3 | 1 | Right 1 | (3 + 1) % 4 | 0 | nums[0] = 2 |

### Output
result = [0, 2, 0, 2]


---

# Complexity
- **Time complexity:**  
  $$O(n)$$  
  We traverse the array exactly once.

- **Space complexity:**  
  $$O(n)$$  
  An additional array of size `n` is used to store the result.

---

# Code
```cpp
class Solution {
public:
    vector<int> constructTransformedArray(vector<int>& nums) {
        int n = nums.size();
        vector<int> result(n);

        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                int newIndex = (i + nums[i]) % n;
                result[i] = nums[newIndex];
            } 
            else if (nums[i] < 0) {
                int newIndex = (i + nums[i] % n + n) % n;
                result[i] = nums[newIndex];
            } 
            else {
                result[i] = 0;
            }
        }

        return result;
    }
};
