# ğŸ§  Intuition

We are given a **sorted array of characters** and a `target` character ğŸ¯.  
Our goal is to find:

ğŸ‘‰ **The smallest character that is strictly greater than `target`**

If no such character exists, we must **wrap around ğŸ”** and return the **first character** of the array.

---

### ğŸ’­ First Thought

The most natural idea is:
- Traverse the array from left â¡ï¸ right
- Return the **first character greater than `target`**

This gives us a straightforward **O(n)** solution.

But waitâ€¦ â³  
The array is **sorted** ğŸ“ˆ â€” which means we can do **much better** using **Binary Search**!

---

# ğŸš€ Approach

## ğŸ”¹ Approach 1: Linear Search (O(n))

### ğŸ’¡ Idea

- Loop through each character
- As soon as you find `letters[i] > target` â†’ return it âœ…
- If the loop ends and nothing is found â†’ **wrap around ğŸ”** and return `letters[0]`

---

### ğŸ” Why This Works

- The array is sorted, so the **first valid character** is also the **smallest valid character**
- The wrap-around case is explicitly mentioned in the problem

---

### âš ï¸ Limitation

- Worst case: you scan the entire array ğŸ˜•
- Time Complexity: **O(n)**

---

## ğŸ”¹ Approach 2: Binary Search (Optimized ğŸ”¥)

### ğŸ§© Key Insight

We are **not** searching for `target` itself.  
We are searching for:

> ğŸŸ¢ **The first character that is greater than `target`**

This is a **classic boundary / lower-bound style binary search** problem.

---

### ğŸ› ï¸ Binary Search â€“ Step by Step

1ï¸âƒ£ Initialize two pointers  
- `s` â†’ start of array  
- `e` â†’ end of array  

2ï¸âƒ£ Keep a variable `ans`  
- Initialize it with `letters[0]`  
- This automatically handles the **wrap-around ğŸ” case**

3ï¸âƒ£ While `s <= e`  
- Calculate `mid` ğŸ§®  
- If `letters[mid] > target`:
  - Store it as a **possible answer** âœ…
  - Move left (`e = mid - 1`) to find a **smaller valid character**
- Else:
  - Move right (`s = mid + 1`)

4ï¸âƒ£ When the loop ends  
- `ans` contains the **correct answer**
- If nothing was greater than `target`, `ans` remains `letters[0]`

---

### ğŸ¯ Why This Is Correct

- Binary search ensures we find the **leftmost valid character**
- Initializing `ans` handles the **circular (wrap-around) behavior**
- Fully utilizes the **sorted property** of the array ğŸ“ˆ

---

# â±ï¸ Complexity

- **Time Complexity**
  - Linear Search: ğŸ¢ **O(n)**
  - Binary Search: âš¡ **O(log n)**

- **Space Complexity**
  - ğŸ§  **O(1)** (constant extra space)

---

# ğŸ’» Code

```java
class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
        int s = 0, e = letters.length - 1;
        char ans = letters[0];  // ğŸ” default wrap-around value

        while (s <= e) {
            int mid = s + (e - s) / 2;

            if (letters[mid] > target) {
                ans = letters[mid];  // âœ… possible answer
                e = mid - 1;         // ğŸ” search left for smaller valid char
            } else {
                s = mid + 1;         // â¡ï¸ move right
            }
        }

        return ans;
    }
}
