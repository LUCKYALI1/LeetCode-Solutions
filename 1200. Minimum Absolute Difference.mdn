# ðŸ§© Minimum Absolute Difference | O(N log N) Sorting Approach

## ðŸ“– Overview
The problem asks us to find all pairs of elements with the minimum absolute difference in an array. The pairs must be returned in ascending order, and each pair `[a, b]` must satisfy `a < b`.

---

## ðŸ’¡ Intuition
Imagine the numbers scattered on a 1D number line. To find the two points closest to each other, you wouldn't jump across the whole line; you would look at immediate neighbors. 

By **sorting** the array, we transform a chaotic search into a structured linear scan. Sorting brings the "closest" values together, ensuring that the minimum difference *must* exist between two adjacent elements.

[Image of a sorted array on a number line showing distances between adjacent nodes]

---

## ðŸ› ï¸ Strategy
We follow a two-pass greedy strategy:

1.  **Normalization (Sorting):** We sort the array in $O(n \log n)$. This handles the requirement of returning pairs in ascending order automatically.
2.  **Distance Calculation:** We iterate once through the sorted array to find the smallest gap ($arr[i+1] - arr[i]$). We store this in `minDiff`.
3.  **Result Construction:** We iterate a second time. Any adjacent pair that matches the `minDiff` is added to our result set.

> **Pro Tip:** While we use two passes for clarity, this can be done in a single pass by clearing the result vector whenever a *new* smaller `minDiff` is found.

---

## ðŸ“Š Complexity Analysis

| Metric | Complexity | Rationale |
| :--- | :--- | :--- |
| **Time Complexity** | $O(n \log n)$ | The bottleneck is the `std::sort()` function. The two linear scans take $O(n)$. |
| **Space Complexity** | $O(\log n)$ | Built-in sort (IntroSort) typically uses $O(\log n)$ auxiliary stack space. |

---

## ðŸ’» Implementation

```cpp
/**
 * Problem: Minimum Absolute Difference
 * Approach: Sorting & Linear Scan
 */
class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        // 1. Sort the array to bring closest elements together
        sort(arr.begin(), arr.end());
        
        vector<vector<int>> ans;
        int n = arr.size();
        if (n < 2) return ans;

        // 2. Identify the global minimum difference
        int minDiff = INT_MAX;
        for (int i = 0; i < n - 1; i++) {
            minDiff = min(minDiff, arr[i + 1] - arr[i]);
        }

        // 3. Collect all pairs that match the minDiff
        for (int i = 0; i < n - 1; i++) {
            if (arr[i + 1] - arr[i] == minDiff) {
                ans.push_back({arr[i], arr[i + 1]});
            }
        }

        return ans;
    }
};
