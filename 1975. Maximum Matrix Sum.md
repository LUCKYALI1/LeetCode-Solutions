# ðŸ”¢ Maximize Matrix Sum â€” Advanced Theory & Solution

## ðŸ§ Problem Analysis
**Goal:** We are given an $n \times n$ matrix. We can perform an operation any number of times: choose two adjacent elements (horizontally or vertically) and multiply them by $-1$. We need to maximize the summation of the matrix elements.

### ðŸ§  The Theory of Sign Propagation
At first glance, the operation allows us to flip signs of **adjacent** elements only. However, this implies a powerful property: **Sign Transfer**.

Imagine a "negative sign" as a token.
1.  If two negative numbers are adjacent, we can flip both. The two "negative tokens" annihilate each other (become positive).
2.  If one number is negative and the adjacent is positive, flipping them "moves" the negative token to the neighbor.

**Theorem:** By applying the operation repeatedly along a path, we can transfer a negative sign from any cell $(r1, c1)$ to any other cell $(r2, c2)$ in the matrix.

### ðŸ’¡ Core Intuition (The Parity Logic)
Since we can move negative signs around and cancel them out in pairs:
* **Case 1: Even number of Negatives.**
    We can pair them all up and cancel them out. The result is the sum of absolute values of all elements.
    $$\text{Result} = \sum_{i,j} |A_{ij}|$$
* **Case 2: Odd number of Negatives.**
    We can cancel all pairs, but **one** negative sign will inevitably remain. We cannot eliminate it.
    To maximize the total sum, we must ensure this single remaining negative sign is assigned to the element with the **smallest absolute value** in the entire matrix.

$$\text{Result} = \sum_{i,j} |A_{ij}| - 2 \times \min(|A_{ij}|)$$

> **Why subtract $2 \times \min$?**
> If we calculate the full absolute sum (assuming all positive), we have effectively added the value of the number that *should* be negative.
> To correct this:
> 1. Remove the positive version (subtract $1 \times val$).
> 2. Add the actual negative version (subtract another $1 \times val$).
> Total subtraction: $2 \times val$.

---

## ðŸš€ Algorithm Design

1.  **Initialize:**
    * `totalSum = 0` (To store sum of absolute values).
    * `minValue = Infinity` (To find the smallest absolute number).
    * `negativeCount = 0` (To track parity).
2.  **Traverse:** Loop through every element of the matrix.
    * Add `abs(val)` to `totalSum`.
    * If `val < 0`, increment `negativeCount`.
    * Update `minValue` with `min(minValue, abs(val))`.
3.  **Finalize:**
    * If `negativeCount` is **Even**: Return `totalSum`.
    * If `negativeCount` is **Odd**: Return `totalSum - 2 * minValue`.

---

## ðŸ“Š Dry Run Table
**Input Matrix:**
$$
\begin{bmatrix}
1 & -2 & 3 \\
-1 & -1 & -4
\end{bmatrix}
$$

**Execution Trace:**

| Iteration (Row, Col) | Value | Abs(Value) | Total Sum | Is Negative? | Neg Count | Min Value Tracked |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: |
| **Start** | - | - | **0** | - | **0** | **$\infty$** |
| (0, 0) | `1` | 1 | 1 | No | 0 | 1 |
| (0, 1) | `-2` | 2 | 3 | Yes | 1 | 1 |
| (0, 2) | `3` | 3 | 6 | No | 1 | 1 |
| (1, 0) | `-1` | 1 | 7 | Yes | 2 | 1 |
| (1, 1) | `-1` | 1 | 8 | Yes | 3 | 1 |
| (1, 2) | `-4` | 4 | 12 | Yes | **4** | 1 |

**Logic Check:**
* Final `negativeCount` is **4** (Even).
* Since it is even, we can turn ALL numbers positive.
* **Result:** `12`.

*(Note: If the count was odd, say 5, and the min value was 1, the result would be $12 - 2(1) = 10$.)*

---

## â±ï¸ Complexity Analysis

- **Time Complexity:** $$O(m \times n)$$
    We traverse the entire matrix exactly once to calculate the sum and find the minimum. $m$ is rows, $n$ is columns.
- **Space Complexity:** $$O(1)$$
    We only store three variables (`totalSum`, `minValue`, `negativeCount`) regardless of the matrix size.

---

## ðŸ§‘â€ðŸ’» Multi-Language Implementation

### C++
```cpp
class Solution {
public:
    long long maxMatrixSum(vector<vector<int>>& matrix) {
        long long totalSum = 0;
        int minValue = INT_MAX;
        int negativeCount = 0;

        for (auto& row : matrix) {
            for (int val : row) {
                totalSum += abs(val);
                if (val < 0) negativeCount++;
                minValue = min(minValue, abs(val));
            }
        }

        // If count is odd, subtract 2 * smallest absolute value
        if (negativeCount % 2 != 0) {
            totalSum -= 2LL * minValue;
        }

        return totalSum;
    }
};
